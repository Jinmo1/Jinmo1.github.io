---
layout: single
title: "Oracle Index란"
Categories: SQL
---

# Oracle Index 종류 및 특징, 주의사항 


**[오라클 인덱스(Index) 란 ]**

```

1. 인덱스(Index)란?

[ 인덱스(index)란? ]
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
```



인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.

```sql
// Mang이라는 이름을 업데이트 해주기 위해서는 Mang을 조회해야 한다.
UPDATE USER SET NAME = 'MangKyu' WHERE NAME = 'Mang';
```

 

만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

  

### [ **오라클 인덱스(Index) 사용 이유 **]

1. 빠른 검색 속도
   - 가장 주요한 이유 중 하나는 빠른 검색 속도를 제공하는 것입니다. 인덱스를 사용하면 데이터베이스 엔진이 특정 값을 가진 행을 빠르게 찾을 수 있어서 SELECT 쿼리의 처리 속도가 향상됩니다.
2. 정렬 및 범위 검색 향상
   - 인덱스는 해당 열의 값을 정렬하여 저장하고 있기 때문에 정렬된 순서대로 데이터에 접근할 수 있습니다. 이는 정렬된 데이터에서의 검색 및 범위 검색(특정 범위 내의 값 검색)에서 효과적인 성능을 제공합니다.
3. 고유성 보장
   - 유니크 인덱스를 통해 특정 열의 값들이 고유하다는 것을 보장할 수 있습니다. 이는 중복된 값을 허용하지 않는 데서 데이터의 정확성을 유지하는 데 도움이 됩니다.
4. 조인 성능 향상
   - 인덱스는 조인 연산 시에도 성능을 향상시킬 수 있습니다. 조인 시 인덱스를 사용하면 조인 대상 테이블에서 빠르게 일치하는 행을 찾아내어 성능을 최적화할 수 있습니다.
5. 그룹화 및 정렬 성능 향상
   - GROUP BY 및 ORDER BY와 같은 집계 함수나 정렬을 수행하는 쿼리에서도 인덱스는 효과적으로 사용될 수 있습니다.
6. 검색 조건 최적화
   - WHERE 절에 사용되는 검색 조건에 해당하는 인덱스를 생성하면 특정 조건에 해당하는 행을 빠르게 찾아낼 수 있습니다.
7. 칼럼 선택 및 필터링
   - 커버링 인덱스를 사용하면 쿼리에 필요한 칼럼을 인덱스에 포함시켜 데이터 테이블에 대한 실제 읽기를 줄일 수 있습니다.

오라클 인덱스는 효율적인 데이터 액세스를 위한 핵심 도구로써, 데이터베이스의 성능 향상을 위해 적절하게 설계 및 활용되어야 합니다.



### [ 인덱스(index)의 관리 ]

DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가함
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

 

### ***\**\*\*\*[ 인덱스(index)의 장점과 단점 ]\*\*\*\*\****

- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

 

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 훨씬 많이 존재하게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 

 

 쿼리 옵티마이저 (Query Optimizer)

다행히도, 데이터베이스 시스템에서는 쿼리 실행 시 적절한 인덱스를 선택하고 사용하는 것을 자동으로 처리하는 `쿼리 옵티마이저(Query Optimizer)`라는 것이 있다.

쿼리 옵티마이저는 인덱스를 사용할 수 있는지, 어떤 인덱스를 사용할지, 어떤 순서로 테이블에 접근해야 하는지 등을 결정한다. 이때 쿼리 옵티마이저는 테이블에 대한 통계 정보, 인덱스 구조, 쿼리 조건 등을 고려하여 최적의 실행 계획을 수립한다.

#### B tree 알고리즘을 사용하는 경우

- 범위 검색(Range Query)
- 중복 값을 가지는 컬럼
- 자주 갱신되는 데이터

#### 해시 알고리즘을 사용하는 경우

- 등호 검색(Exact Match Query)
- 고정 길이의 키(Key)
- 자주 갱신되지 않는 데이터

 

### ***\**\*\*\*[ 인덱스(index)를 사용하면 좋은 경우 ]\*\*\*\*\****

- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
- 기타 등등

인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다. 

 

 

 

## **2. 인덱스(Index)의 자료구조**

------

인덱스를 구현하기 위해서는 다양한 자료구조를 사용할 수 있는데, 가장 대표적인 해시 테이블과 B+Tree에 대해서 알아보도록 하자.

 

### ***\**\*\*\*[ 해시 테이블(Hash Table) ]\*\*\*\*\****

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.



![img](https://blog.kakaocdn.net/dn/RpMoO/btqKMzdg9TX/XYkGt2kqE0hr9rqhHx3o3K/img.png)



 

해시 테이블 기반의 DB 인덱스는 (데이터=컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.

하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

즉, 예를 들면 "나는"으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못하게 된다. 이러한 이유로 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용된다.

 

 

 

### ***\**\*\*\*[ B+Tree ]\*\*\*\*\****

B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화하였다. (물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.)

이러한 이유로 비록 B+Tree는 O(log2nlog2n{log_2n}) 의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.

 



![img](https://blog.kakaocdn.net/dn/d78iJ0/btqKRYbLdM9/nIvz1M4gffMl4YHS77JSfK/img.png)



 

 

InnoDB에서의 B+Tree는 일반적인 구조보다 더욱 복잡하게 구현이 되었다. InnoDB에서는 같은 레벨의 노드들끼리는 Linked List가 아닌 Double Linked List로 연결되었으며, 자식 노드들은 Single Linked List로 연결되어 있다.



### Oracle Index 종류



### **(1) B-트리 인덱스**

B-트리 인덱스는 오라클에서 가장 일반적으로 사용되는 인덱스 유형입니다. 기본적으로 정렬된 키-값 쌍을 유지하며, 이진 트리 구조를 사용하여 빠른 검색을 지원합니다.



[ 인덱스 구조와 작동 원리(B-TREE 인덱스 기준) ]   

```
 테이블(Table)과 인덱스(Index)의 비교
 - 테이블은 컬럼이 여러개, 데이터가 "정렬되지 않고" 입력된 순서대로 들어간다.                            vs    
 - 인덱스(Index)는 컬럼이 "Key컬럼(사용자가 인덱스를 지정하라고 지정한 컬럼)"과 "ROWID컬럼" 두개로 이루어져 있다.(오름차순, 내림차순으로 정렬 가능)
 
 */select * from emp where empno = 7902; -- 를 찾을 때/*  
 
 데이터 파일의 블록이 10만개가 있다고 할 때 sql문을 수행한다면,  
 1) 서버 프로세스가 구문파싱 과정을 마친 후 DB Buffer 캐시에 empno가 7902인 정보가 있는지를 먼저 확인한다.  
 2) 해당 정보가 캐시에 없다면 디스크 파일에서 7902정보를 가진 블럭을 찾아서 DB Buffer 캐시로 가져온 뒤 해당 정보를 사용자에게 보여줌  이 경우에    
 - Index가 없는 경우 -> 7902정보가 디스크 어떤 블럭에 있는지 모름으로 10만개 전부 DB Buffer 캐시로 복사한 뒤 Full Scan으로 찾게 됨.    
 - Index가 있는 경우 -> where절의 조건으로 준 컬럼이 Index의 Key로 생성되어 있는지 확인한 뒤, 인덱스에 먼저 가서 7902정보가 어떤 ROWID를 가지고 있는지 확인한 뒤 해당 ROWID에 있는 블럭만 찾아가서 db Buffer 캐시에 복사하게 됨.
```



### **(2) 비트맵 인덱스**

비트맵 인덱스는 특정 값을 가진 행들을 비트맵 형태로 저장하여 검색 속도를 높이는 인덱스 유형입니다.



### **(3) 유니크 인덱스**

유니크 인덱스는 특정 열의 값이 중복되지 않도록 보장하는 인덱스로, 주로 기본 키 제약 조건을 구현하기 위해 사용됩니다.

### **(4) 함수 기반 인덱스**

함수 기반 인덱스는 특정 함수의 결과에 기반하여 인덱스를 생성하는 방식으로, 특정 연산 또는 조작이 필요한 경우에 사용됩니다.

![image-20240509170156381](C:\Users\황혜림(Wi-Fi)\AppData\Roaming\Typora\typora-user-images\image-20240509170156381.png)

### **(6) \**클러스터 인덱스\****

클러스터 인덱스는 테이블 데이터의 물리적 순서를 변경하여 인덱스를 생성하는 방식으로, 인접한 데이터에 대한 검색 성능을 향상시킵니다.

![image-20240509170254189](C:\Users\황혜림(Wi-Fi)\AppData\Roaming\Typora\typora-user-images\image-20240509170254189.png)



### 쿼리 옵티마이저 (Query Optimizer)

다행히도, 데이터베이스 시스템에서는 쿼리 실행 시 적절한 인덱스를 선택하고 사용하는 것을 자동으로 처리하는 `쿼리 옵티마이저(Query Optimizer)`라는 것이 있다.

쿼리 옵티마이저는 인덱스를 사용할 수 있는지, 어떤 인덱스를 사용할지, 어떤 순서로 테이블에 접근해야 하는지 등을 결정한다. 이때 쿼리 옵티마이저는 테이블에 대한 통계 정보, 인덱스 구조, 쿼리 조건 등을 고려하여 최적의 실행 계획을 수립한다.

#### B tree 알고리즘을 사용하는 경우

- 범위 검색(Range Query)
- 중복 값을 가지는 컬럼
- 자주 갱신되는 데이터

#### 해시 알고리즘을 사용하는 경우

- 등호 검색(Exact Match Query)
- 고정 길이의 키(Key)
- 자주 갱신되지 않는 데이터



 **5. [ 인덱스 주의사항 ]**

```
- 인덱스를 사용하면 무조건 효율이 좋을까? NO       
  -> [ 인덱스는 DML에 취약 ]  
  
  근거) 
  1) INSERT 작업의 경우 : "index split"현상이 발생할 수 있다. 
    - Index Split이란? : 인덱스의 Block들이 하나에서 두개로 나누어지는 현상-> 인덱스는 데이터가 순서대로 정렬되어 저장되게 되는데, 기존 블럭에 여유 공간이 없는 상황에서 그 블럭에 새로운 데이터가 입력되어야 하는 경우 오라클은 기존 블럭의 내용 중 일부를 새 블럭에다가 기록한 다음 기존 블럭에 빈 공간을 만들어서 새로운 데이터를 추가하게 된다.
    --> 따라서, 성능면에서 매우 불리하다.           
  a)Index Split은 새로운 블럭을 할당 받고 key를 옮기는 복잡한 작업을 수행           
  b)Index Split이 이루어지는 동안 해당 블럭에 대해 키 값이 변경되면 안되므로 DML이 블로킹된다.     enq:TX-index contention 대기 이벤트 발생(RAC-gc current split)
  
  2) DELETE 작업의 경우 : 일반적인 테이블에서 데이터가 delete될 경우 해당 위치 데이터가 지워지고 그 공간을 사용 가능하다. 
  하지만, Index에서 데이터가 delete될 경우 -> "데이터는 지워지지 않고, 사용하지 않는다는 의미의 표시만 해두게 된다!"            
  --> 즉, 테이블에 2만건의 데이터가 있었는데 1만건을 삭제해도 Index에는 데이터가 2만건이 존재한다는 말이된다.            
  -> 인덱스를 사용해도 수행속도를 기대하기는 힘들다.
  
  3) UPDATE 작업의 경우  : 인덱스에는 UPDATE란 작업이 존재하지 않기 때문에 
    기존의 데이터를 DELETE한 다음 새로운 값의 데이터를 INSERT하는 두번의 과정으로 작업 발생
    따라서, 다른 DML작업보다 더 큰 부하를 주게 된다.
```

**[ 최종적으로 인덱스 생성시 고려해야할 사항 ]**

```
1 일반적으로 테이블 전체 로우(Row) 수의 15%이하의 데이터를 조회할 때 인덱스를 생성한다.

2 테이블 건수가 상당히 적다면 굳이 인덱스를 만들 필요가 없다. -> 테이블 건수가 적으면 인덱스를 경유하기보다 테이블 전체를 스캔하는 것이 더 빠르다.

3 인덱스 생성시 컬럼은 유일성 정도가 좋거나 범위가 넓은 값을 가진 컬럼을 지정하는 것이 좋다. (NULL값을 많이 갖는 컬럼은 피하는 것이 좋다.)

4 결합 인덱스 생성시에는 컬럼의 순서가 중요하다.-> 보통, 자주 사용하는 컬럼을 앞에 지정한다.

5 테이블에 만들 수 있는 인덱스의 수는 제한이 없으나, 너무 많이 만들면 오히려 성능 부하가 발생한다.why? -> 인덱스 생성을 해 놓으면 해당 테이블에 DML 작업(insert, delete, update)시 인덱스에도 수정작업이 동시에 발생하기 때문에 과도하게 많은 인덱스를 생성해 놓으면오히려 성능 부하가 걸릴 수 있다.-> 일반적으로, 테이블 당 최대 5개를 넘지 않는 것이 좋다.

6 데이터의 검색보다 수정, 삭제, 삽입 작업이 빈번한 테이블에는 인덱스를 생성하지 않는 것이 좋다.-> 인덱스는 DML작업에는 성능이 좋지 않기 때문에 검색을 위주로 하는 테이블에 생성하는 것이 좋다.(위에서 언급한 성능 이슈들이 발생할 수 있다.)
```

